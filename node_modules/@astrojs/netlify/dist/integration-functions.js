import { writeFile } from 'node:fs/promises';
import { extname, join } from 'node:path';
import { fileURLToPath } from 'node:url';
import { generateEdgeMiddleware } from './middleware.js';
import { createRedirects } from './shared.js';
export const NETLIFY_EDGE_MIDDLEWARE_FILE = 'netlify-edge-middleware';
export const ASTRO_LOCALS_HEADER = 'x-astro-locals';
export function getAdapter({ functionPerRoute, edgeMiddleware, ...args }) {
    return {
        name: '@astrojs/netlify/functions',
        serverEntrypoint: '@astrojs/netlify/netlify-functions.js',
        exports: ['handler'],
        args,
        adapterFeatures: {
            functionPerRoute,
            edgeMiddleware,
        },
        supportedAstroFeatures: {
            hybridOutput: 'stable',
            staticOutput: 'stable',
            serverOutput: 'stable',
            assets: {
                supportKind: 'stable',
                isSharpCompatible: true,
                isSquooshCompatible: true,
            },
        },
    };
}
function netlifyFunctions({ dist, builders, binaryMediaTypes, functionPerRoute = false, edgeMiddleware = false, } = {}) {
    let _config;
    let _entryPoints;
    let ssrEntryFile;
    let _middlewareEntryPoint;
    return {
        name: '@astrojs/netlify',
        hooks: {
            'astro:config:setup': ({ config, updateConfig }) => {
                const outDir = dist ?? new URL('./dist/', config.root);
                updateConfig({
                    outDir,
                    build: {
                        redirects: false,
                        client: outDir,
                        server: new URL('./.netlify/functions-internal/', config.root),
                    },
                });
            },
            'astro:build:ssr': async ({ entryPoints, middlewareEntryPoint }) => {
                if (middlewareEntryPoint) {
                    _middlewareEntryPoint = middlewareEntryPoint;
                }
                _entryPoints = entryPoints;
            },
            'astro:config:done': ({ config, setAdapter }) => {
                setAdapter(getAdapter({
                    binaryMediaTypes,
                    builders,
                    functionPerRoute,
                    edgeMiddleware,
                }));
                _config = config;
                ssrEntryFile = config.build.serverEntry.replace(/\.m?js/, '');
                if (config.output === 'static') {
                    // eslint-disable-next-line no-console
                    console.warn(`[@astrojs/netlify] \`output: "server"\` or \`output: "hybrid"\` is required to use this adapter.`);
                    // eslint-disable-next-line no-console
                    console.warn(`[@astrojs/netlify] Otherwise, this adapter is not required to deploy a static site to Netlify.`);
                }
            },
            'astro:build:done': async ({ routes, dir }) => {
                const functionsConfig = {
                    version: 1,
                    config: {
                        nodeModuleFormat: 'esm',
                    },
                };
                const functionsConfigPath = join(fileURLToPath(_config.build.server), 'entry.json');
                await writeFile(functionsConfigPath, JSON.stringify(functionsConfig));
                const type = builders ? 'builders' : 'functions';
                const kind = type ?? 'functions';
                if (_entryPoints.size) {
                    const routeToDynamicTargetMap = new Map();
                    for (const [route, entryFile] of _entryPoints) {
                        const wholeFileUrl = fileURLToPath(entryFile);
                        const extension = extname(wholeFileUrl);
                        const relative = wholeFileUrl
                            .replace(fileURLToPath(_config.build.server), '')
                            .replace(extension, '')
                            .replaceAll('\\', '/');
                        const dynamicTarget = `/.netlify/${kind}/${relative}`;
                        routeToDynamicTargetMap.set(route, dynamicTarget);
                    }
                    await createRedirects(_config, routeToDynamicTargetMap, dir);
                }
                else {
                    const dynamicTarget = `/.netlify/${kind}/${ssrEntryFile}`;
                    const map = routes.map((route) => {
                        return [route, dynamicTarget];
                    });
                    const routeToDynamicTargetMap = new Map(Array.from(map));
                    await createRedirects(_config, routeToDynamicTargetMap, dir);
                }
                if (_middlewareEntryPoint) {
                    const outPath = fileURLToPath(new URL('./.netlify/edge-functions/', _config.root));
                    const netlifyEdgeMiddlewareHandlerPath = new URL(NETLIFY_EDGE_MIDDLEWARE_FILE, _config.srcDir);
                    await generateEdgeMiddleware(_middlewareEntryPoint, outPath, netlifyEdgeMiddlewareHandlerPath);
                }
            },
        },
    };
}
export { netlifyFunctions as default, netlifyFunctions };
